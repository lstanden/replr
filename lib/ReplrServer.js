// Generated by CoffeeScript 1.10.0
(function() {
  var EventEmitter, MemoryStream, ReplrClient, ReplrEvents, ReplrServer, Util, async, chalk, cluster, extend, http, net, portscanner, terminal,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  net = require('net');

  http = require('http');

  extend = require('xtend');

  cluster = require('cluster');

  chalk = require('chalk');

  terminal = require('terminal');

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  MemoryStream = require('memorystream');

  portscanner = require('portscanner');

  ReplrClient = require('./ReplrClient');

  ReplrEvents = require('./ReplrEvents');

  Util = require('./Util');

  ReplrServer = (function(superClass) {
    extend1(ReplrServer, superClass);

    ReplrServer.prototype.OPTIONS_DEFAULT = {
      name: 'Replr',
      port: 2323,
      mode: 'http',
      prompt: chalk.gray('replr> '),
      terminal: false,
      useColors: false,
      describeWorker: null
    };

    ReplrServer.prototype.OPTIONS_MODES = ['http', 'tcp', 'unixdomainsocket', 'raw', 'noserver'];

    ReplrServer.prototype.OPTIONS_REPL_KEYS = ['port', 'prompt', 'terminal', 'useColors', 'useGlobal', 'ignoreUndefined'];

    function ReplrServer(options, start) {
      if (start == null) {
        start = true;
      }
      options = options || {};
      if (options.port) {
        if (typeof options.port === 'number') {
          if (!Util.prototype.isInt(options.port) || options.port < 1) {
            throw new Error('bad port');
          }
        } else if (typeof options.port !== 'string') {
          throw new Error('bad port');
        }
      }
      if (options.prompt) {
        if (typeof options.prompt !== 'string') {
          throw new Error('bad prompt');
        }
      }
      if (options.mode) {
        if (this.OPTIONS_MODES.indexOf(options.mode) === -1) {
          throw new Error('bad mode');
        }
      }
      this.options = extend(this.OPTIONS_DEFAULT, options);
      this.clients = [];
      this.started = false;
      this.starting = false;
      if (start) {
        return this.start();
      } else {
        return this;
      }
    }

    ReplrServer.prototype.start = function(callback) {
      var onVerified, ready;
      ready = (function(_this) {
        return function() {
          _this.started = true;
          _this.starting = false;
          return _this.emit('listening');
        };
      })(this);
      if (this.starting) {
        return;
      }
      this.starting = true;
      if (this.options.mode === 'noserver' || this.options.port === false) {
        return ready();
      }
      onVerified = (function(_this) {
        return function(err, status) {
          var error, mode, onError;
          if (err || status === 'open') {
            if (callback) {
              callback(err || new Error('Port already taken'));
            }
            return;
          }
          mode = _this.options.mode;
          if (mode === 'tcp' || mode === 'unixdomainsocket' || mode === 'raw') {
            _this.socketServer = net.createServer(_this.open.bind(_this));
          } else {
            _this.socketServer = http.createServer(function() {});
            _this.socketServer.on('upgrade', function(req, socket, head) {
              var error, exc, str;
              try {
                str = head.toString('utf8');
                if (req.headers && req.headers.upgrade === 'replr') {
                  return _this.open(socket);
                } else {
                  return socket.end();
                }
              } catch (error) {
                exc = error;
                return socket.end();
              }
            });
          }
          _this.socketServer.on('listening', function() {
            return ready();
          });
          onError = function(err) {
            if (callback) {
              return callback(err);
            }
          };
          _this.socketServer.once('error', onError);
          try {
            _this.socketServer.listen(_this.options.port);
          } catch (error) {
            err = error;
            _this.started = false;
            _this.starting = false;
            if (callback) {
              callback(err);
            }
          }
          return _this.socketServer.removeListener('error', onError);
        };
      })(this);
      if (this.options.port === 0) {
        return onVerified(null, 'free');
      } else if (typeof this.options.port === 'number') {
        return portscanner.checkPortStatus(this.options.port, '127.0.0.1', onVerified);
      } else {
        return onVerified(null, 'free');
      }
    };

    ReplrServer.prototype.close = function(callback) {
      if (this.starting) {
        return this.once('listening', (function(_this) {
          return function() {
            return _this.close(callback);
          };
        })(this));
      } else if (this.started) {
        return this.socketServer.close((function(_this) {
          return function() {
            _this.started = false;
            _this.emit('close');
            if (callback) {
              return callback();
            }
          };
        })(this));
      } else {
        if (callback) {
          return callback(new Error('Already closed'));
        }
      }
    };

    ReplrServer.prototype.open = function(socket, overriddenOptions) {
      var client, clientOptions, exports, i, key, len, originalValue, ref, ref1, replOptions, value;
      if (overriddenOptions == null) {
        overriddenOptions = {};
      }
      replOptions = {};
      ref = this.OPTIONS_REPL_KEYS;
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        if (this.options.hasOwnProperty(key)) {
          replOptions[key] = this.options[key];
        }
      }
      clientOptions = extend(overriddenOptions, this.options);
      client = new ReplrClient(this, socket, clientOptions, replOptions);
      this.clients.push(client);
      socket.on('end', (function(_this) {
        return function() {
          return _this.clients.splice(_this.clients.indexOf(client), 1);
        };
      })(this));
      socket.on('error', (function(_this) {
        return function(err) {
          if (err && err.code === 'EPIPE') {

          }
        };
      })(this));
      client.repl.context.exported = {};
      ref1 = client.exports();
      for (key in ref1) {
        value = ref1[key];
        client.repl.context.exported[key] = value;
        client.repl.context[key] = value;
      }
      if (this.options.exports && typeof this.options.exports === 'function') {
        exports = this.options.exports(client);
        if (exports && Object.keys(exports).length > 0) {
          for (key in exports) {
            value = exports[key];
            if (typeof value === 'function') {
              originalValue = value;
              value = value.bind(client.repl.context);
              value.unbound = originalValue;
            }
            client.repl.context.exported[key] = value;
            client.repl.context[key] = value;
          }
        }
      }
      client.welcome();
      return client;
    };

    ReplrServer.prototype.forwardToWorker = function(client, worker) {
      var dummy, msg;
      msg = {
        type: ReplrEvents.prototype.WORKER_RECEIVE,
        options: this.options
      };
      dummy = new MemoryStream();
      client.repl.inputStream = dummy;
      client.repl.outputStream = dummy;
      client.repl.rli.input = dummy;
      client.repl.rli.output = dummy;
      return worker.send(msg, client.socket);
    };

    ReplrServer.prototype.describeWorkers = function(callback) {
      var formatTitle, id, worker, workersArray;
      formatTitle = function(id, worker) {
        return "[" + id + "] id=" + id + ", pid=" + worker.process.pid + "\n";
      };
      if (typeof this.options.describeWorker === 'function') {
        workersArray = (function() {
          var ref, results1;
          ref = cluster.workers;
          results1 = [];
          for (id in ref) {
            worker = ref[id];
            results1.push(worker);
          }
          return results1;
        })();
        return async.map(workersArray, (function(_this) {
          return function(worker, cb) {
            return _this.options.describeWorker(worker, function(description) {
              var str;
              str = "" + (formatTitle(worker.id, worker)) + (terminal.lpad(description, 1));
              return cb(null, str);
            });
          };
        })(this), (function(_this) {
          return function(err, results) {
            return callback(results.join("\n"));
          };
        })(this));
      } else {
        return callback(((function() {
          var ref, results1;
          ref = cluster.workers;
          results1 = [];
          for (id in ref) {
            worker = ref[id];
            results1.push(formatTitle(id, worker));
          }
          return results1;
        })()).join("\n"));
      }
    };

    return ReplrServer;

  })(EventEmitter);

  module.exports = ReplrServer;

}).call(this);
