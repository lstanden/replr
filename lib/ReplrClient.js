// Generated by CoffeeScript 1.10.0
(function() {
  var InputInterceptor, ReplrClient, Transform, async, chalk, cluster, doc, repl, terminal, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  async = require('async');

  repl = require('repl');

  cluster = require('cluster');

  chalk = require('chalk');

  doc = require('doc');

  terminal = require('terminal');

  util = require('util');

  Transform = require('stream').Transform;

  ReplrClient = (function() {
    var key, ref, value;

    ReplrClient.prototype.TERM_CODES = {
      clear: '\u001B[2J',
      clearToEndOfLine: '\u001b[K',
      zeroPos: '\u001B[0;0f',
      moveLeft: '\u001b[D',
      moveRight: '\u001b[C',
      moveUp: '\u001b[A',
      moveDown: '\u001b[B',
      saveCursor: '\u001b7',
      restoreCursor: '\u001b8'
    };

    ReplrClient.prototype.TERM_CODES_VALUES = [];

    ref = ReplrClient.prototype.TERM_CODES;
    for (key in ref) {
      value = ref[key];
      ReplrClient.prototype.TERM_CODES_VALUES.push(value);
    }

    function ReplrClient(server, socket, options1, replOptions) {
      this.server = server;
      this.socket = socket;
      this.options = options1;
      this.width = this.options.width || 80;
      this.height = this.options.height || 40;
      replOptions.input = this.socket;
      replOptions.output = this.socket;
      this.repl = repl.start(replOptions);
      this.repl.on('exit', (function(_this) {
        return function() {
          return _this.socket.end();
        };
      })(this));
    }

    ReplrClient.prototype.resize = function(width, height) {
      if (typeof width === 'number' && typeof height === 'number') {
        this.width = width;
        return this.height = height;
      }
    };

    ReplrClient.prototype.write = function(msg, callback) {
      var err, error, k, len, ref1;
      if (callback == null) {
        callback = null;
      }
      if (!this.options.terminal) {
        msg = terminal.stripStyles(msg);
        ref1 = this.TERM_CODES_VALUES;
        for (k = 0, len = ref1.length; k < len; k++) {
          value = ref1[k];
          try {
            msg = msg.replace(new RegExp(value, 'g'), '');
          } catch (error) {
            err = error;
          }
        }
      }
      if (!this.options.useColors) {
        msg = chalk.stripColor(msg);
      }
      if (callback) {
        return this.socket.write(msg, callback);
      } else {
        return this.socket.write(msg);
      }
    };

    ReplrClient.prototype.send = function(result, callback) {
      if (callback == null) {
        callback = null;
      }
      this.write("\n" + (this.indent(result, 2)) + "\n\n", callback);
    };

    ReplrClient.prototype.indent = function(str, indentBy) {
      var i, k, ref1, spaces;
      spaces = '';
      for (i = k = 1, ref1 = indentBy; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        spaces += ' ';
      }
      return "" + spaces + (str.replace(/\n/g, "\n" + spaces));
    };

    ReplrClient.prototype.exports = function() {
      var cmds, exports, select, vars, workers, write;
      cmds = (function(_this) {
        return function() {
          ({
            doc: "Prints all available commands in the local REPL context with documentation"
          });
          return _this.send(_this.getCommands());
        };
      })(this);
      vars = (function(_this) {
        return function() {
          ({
            doc: "Prints all available variables in the local REPL context and their types"
          });
          return _this.send(_this.getVars());
        };
      })(this);
      workers = (function(_this) {
        return function() {
          ({
            doc: "Prints all workers running on this cluster"
          });
          _this.getWorkersDescription(function(description) {
            return _this.send(description);
          });
        };
      })(this);
      select = (function(_this) {
        return function(workerId) {
          ({
            doc: "Changes into the worker context with the given workerId"
          });
          return _this.changeWorker(workerId);
        };
      })(this);
      write = (function(_this) {
        return function(obj, options) {
          var text;
          if (options == null) {
            options = {
              colors: true
            };
          }
          ({
            doc: "Writes text or util.inspect(obj, text) to this REPL session, useful for other exported methods"
          });
          text = typeof obj === 'string' ? obj : util.inspect(obj, options);
          _this.send(text);
        };
      })(this);
      exports = {
        help: 'Type .help for repl help, use cmds() to get commands in current context',
        exit: 'Did you mean .exit?',
        repl: this.repl,
        replOptions: this.options,
        cmds: cmds,
        vars: vars,
        write: write
      };
      if (cluster.isMaster) {
        exports.workers = workers;
        exports.select = select;
      }
      return exports;
    };

    ReplrClient.prototype.changeWorker = function(workerId) {
      var ref1, worker;
      ref1 = cluster.workers;
      for (key in ref1) {
        worker = ref1[key];
        if (worker.id === workerId) {
          this.server.forwardToWorker(this, worker);
          return;
        }
      }
      return this.send("Could not find worker with worker ID '" + workerId + "'");
    };

    ReplrClient.prototype.getCommands = function() {
      var commands, described, descriptions, exported, func, indentBy, k, l, len, len1, longest, ref1, signature, signatureAsString;
      exported = {};
      ref1 = this.repl.context.exported;
      for (key in ref1) {
        value = ref1[key];
        exported[key] = typeof value.unbound === 'function' ? value.unbound : value;
      }
      commands = (function() {
        var k, len, ref2, results1;
        ref2 = Object.keys(exported);
        results1 = [];
        for (k = 0, len = ref2.length; k < len; k++) {
          key = ref2[k];
          if (typeof exported[key] === 'function') {
            results1.push(key);
          }
        }
        return results1;
      })();
      signatureAsString = function(name, func) {
        return key + "(" + (doc.docArgsAsArray(func).join(', ')) + ")";
      };
      longest = 0;
      for (k = 0, len = commands.length; k < len; k++) {
        key = commands[k];
        signature = signatureAsString(key, exported[key]);
        if (signature.length > longest) {
          longest = signature.length;
        }
      }
      indentBy = longest + 6;
      descriptions = [];
      for (l = 0, len1 = commands.length; l < len1; l++) {
        key = commands[l];
        func = exported[key];
        signature = terminal.rpad(signatureAsString(key, func), indentBy);
        described = '';
        terminal.printWrapped(doc.docAsString(func), this.options.width, indentBy, function(out) {
          return described += out + "\n";
        });
        descriptions.push("" + signature + (described.substring(indentBy)));
      }
      if (descriptions.length > 0) {
        descriptions.unshift('');
        descriptions.unshift((terminal.rpad('--', indentBy)) + "--");
        descriptions.unshift((terminal.rpad('function', indentBy)) + "documentation");
        descriptions.unshift('');
        descriptions.unshift(chalk.cyan("(" + commands.length + ") commands in the local REPL context"));
      } else {
        descriptions = [chalk.cyan("There are no commands in the local REPL context")];
      }
      return descriptions.join("\n");
    };

    ReplrClient.prototype.getVars = function() {
      var descriptions, exported, formattedKey, indentBy, k, l, len, len1, longest, vars;
      exported = this.repl.context.exported;
      vars = (function() {
        var k, len, ref1, results1;
        ref1 = Object.keys(exported);
        results1 = [];
        for (k = 0, len = ref1.length; k < len; k++) {
          key = ref1[k];
          if (typeof exported[key] !== 'function') {
            results1.push(key);
          }
        }
        return results1;
      })();
      longest = 0;
      for (k = 0, len = vars.length; k < len; k++) {
        key = vars[k];
        if (key.length > longest) {
          longest = key.length;
        }
      }
      indentBy = longest + 6;
      descriptions = [];
      for (l = 0, len1 = vars.length; l < len1; l++) {
        key = vars[l];
        value = exported[key];
        formattedKey = terminal.rpad(key, indentBy);
        descriptions.push("" + formattedKey + (typeof value));
      }
      if (descriptions.length > 0) {
        descriptions.unshift('');
        descriptions.unshift((terminal.rpad('--', indentBy)) + "--");
        descriptions.unshift((terminal.rpad('name', indentBy)) + "info");
        descriptions.unshift('');
        descriptions.unshift(chalk.cyan("(" + vars.length + ") variables in the local REPL context"));
      } else {
        descriptions = [chalk.cyan("There are no variables in the local REPL context")];
      }
      return descriptions.join("\n");
    };

    ReplrClient.prototype.getWorkersDescription = function(callback) {
      return this.server.describeWorkers((function(_this) {
        return function(description) {
          var active, nonEssentialLineBreak, plural;
          active = Object.keys(cluster.workers).length;
          plural = active !== 1 ? 's' : '';
          nonEssentialLineBreak = active > 0 ? "\n" : '';
          return callback((chalk.cyan("(" + active + ") worker" + plural + " active" + nonEssentialLineBreak)) + "\n" + description);
        };
      })(this));
    };

    ReplrClient.prototype.welcome = function() {
      return this.getWelcomeMessage((function(_this) {
        return function(message) {
          return _this.write([_this.TERM_CODES.clear, _this.TERM_CODES.zeroPos, message].join(''));
        };
      })(this));
    };

    ReplrClient.prototype.getWelcomeMessage = function(callback) {
      var hint, title;
      title = chalk.cyan.bold('Welcome');
      hint = 'Hint: use cmds() to print the current exports available to you';
      if (cluster.isMaster) {
        return this.getWorkersDescription((function(_this) {
          return function(description) {
            return callback(title + " " + _this.options.name + "[cluster.Master]\n\n" + (_this.indent(description, 2)) + "\n\n" + hint + "\n\n" + (_this.repl._prompt || _this.repl.prompt));
          };
        })(this));
      } else {
        return callback(title + " to " + this.options.name + "[cluster.Worker]\n\n" + hint + "\n\n" + (this.repl._prompt || this.repl.prompt));
      }
    };

    ReplrClient.prototype.getTabCompletions = function(input, callback) {
      return this.repl.complete(input, (function(_this) {
        return function(err, results) {
          var columns, columnsText, completions, i, j, k, l, len, longest, m, padding, ref1, ref2, remaining, rows, text;
          if (!err) {
            completions = results[0];
            longest = 0;
            for (k = 0, len = completions.length; k < len; k++) {
              key = completions[k];
              if (key.length > longest) {
                longest = key.length;
              }
            }
            columns = Math.floor(_this.width / longest);
            rows = Math.ceil(completions.length / columns);
            remaining = completions.concat().sort();
            columnsText = [];
            while (columnsText.length < columns) {
              columnsText.push(remaining.splice(0, rows));
            }
            text = '';
            padding = 2;
            for (i = l = 0, ref1 = rows; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
              for (j = m = 0, ref2 = columns; 0 <= ref2 ? m < ref2 : m > ref2; j = 0 <= ref2 ? ++m : --m) {
                if (columnsText[j][i]) {
                  text += terminal.rpad(columnsText[j][i], longest + padding);
                }
              }
              text += '\n';
            }
            return callback(text, completions);
          } else {
            return callback('', []);
          }
        };
      })(this));
    };

    return ReplrClient;

  })();

  InputInterceptor = (function(superClass) {
    extend(InputInterceptor, superClass);

    InputInterceptor.prototype.MAX_PAST_ENTRIES = 64;

    function InputInterceptor(options) {
      InputInterceptor.__super__.constructor.call(this, options);
      this.client = options.client;
      this.socket = options.socket;
      this.socket.pipe(this);
      this.inputBuffer = '';
      this.pastEntries = [];
      this.inputCursor = 0;
    }

    InputInterceptor.prototype.resume = function() {
      return this.socket.resume();
    };

    InputInterceptor.prototype._transform = function(chunk, encoding, callback) {
      var error, exc, input, k, ref, results1;
      input = '';
      try {
        input = chunk.toString('utf8');
      } catch (error) {
        exc = error;
        this.push(chunk);
        return callback();
      }
      return async.each((function() {
        results1 = [];
        for (var k = 0, ref = input.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results1.push(k); }
        return results1;
      }).apply(this), (function(_this) {
        return function(i, nextCallback) {
          var charCode;
          charCode = input[i].charCodeAt(0);
          return _this._transformSingleInput(input[i], charCode, nextCallback);
        };
      })(this), callback);
    };

    InputInterceptor.prototype._transformSingleInput = function(input, charCode, callback) {
      if (input === '\t') {
        return this.client.getTabCompletions(this.inputBuffer, (function(_this) {
          return function(text, completions) {
            var remaining;
            if (completions.length === 1) {
              remaining = completions[0].substr(_this.inputBuffer.length);
              _this.inputBuffer += remaining;
              _this.client.write(remaining);
              return callback();
            } else {
              _this.client.write("\n" + text + (_this.client.repl._prompt || _this.client.repl.prompt) + _this.inputBuffer);
              return callback();
            }
          };
        })(this));
      } else if (input === '\n' || input === '\r') {
        this.push(this.inputBuffer);
        this.pastEntries.push(this.inputBuffer);
        if (this.pastEntries.length > this.MAX_PAST_ENTRIES) {
          this.pastEntries = this.pastEntries.slice(1);
        }
        this.inputBuffer = '';
        this.inputCursor = 0;
        this.push(input);
        return callback();
      } else if (charCode === 127) {
        if (this.inputBuffer.length > 0) {
          this.inputBuffer = this.inputBuffer.slice(0, -1);
          this.client.write(ReplrClient.prototype.TERM_CODES.moveLeft);
          this.client.write(ReplrClient.prototype.TERM_CODES.clearToEndOfLine);
          this.inputCursor--;
        }
        return callback();
      } else {
        if ((charCode > 31 && charCode < 127) || charCode > 160) {
          this.inputCursor++;
          this.inputBuffer += input;
        }
        return callback();
      }
    };

    return InputInterceptor;

  })(Transform);

  module.exports = ReplrClient;

}).call(this);
